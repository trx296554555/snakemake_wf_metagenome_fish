#!/usr/bin/env python
####################################################################
# bracken_to_trx.py converts a bracken report (Kraken-style) into trx format
# Copyright (C) 2023-2026 Robin Tang, rbio_tang@foxmail.com

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>.
#
####################################################################
# Robin Tang, rbio_tang@foxmail.com
# 2023/11/27
#
# This program, modified from kreport2mpa.py, is designed to process reports generated by Bracken,
# converting them into the trx format. The trx format is similar to the mpa format but exclusively
# records the number of reads classified at the current level. It includes an added taxid column
# and fully populates the hierarchical relationships for subsequent analysis in R. Note that results
# generated by Bracken may not be suitable for some bottom-up processing workflows, as the need to
# ensure integer values for assigned reads can lead to a mismatch between the total reads classified
# at the current level and the recorded total at the root. Therefore, the trx format is employed to
# address this issue.
#

import os, argparse

def process_bracken_report(curr_str):
    split_str = curr_str.strip().split('\t')
    if len(split_str) < 4:
        return []
    try:
        int(split_str[1])
    except ValueError:
        return []
    percents = float(split_str[0])
    all_reads = int(split_str[1])
    cur_reads = int(split_str[2])
    taxid = int(split_str[-2])
    level_type = split_str[-3]
    # Get name and spaces
    spaces = 0
    name = split_str[-1]
    for char in name:
        if char == ' ':
            name = name[1:]
            spaces += 1
        else:
            break
    name = name.replace(' ', '_')
    # Determine level based on number of spaces
    level_num = spaces / 2
    return [name, level_num, taxid, level_type, cur_reads, all_reads, percents]


def full_level(in_list):
    rank_list = ['k', 'p', 'c', 'o', 'f', 'g', 's']
    out_list = []
    for line in in_list:
        line_list = line.strip().split('\t')
        taxon = line_list[1]
        taxon_list = taxon.split('|')
        rank_tile = rank_list.index(taxon_list[-1][0])
        if len(taxon_list) == 1:
            taxon_list = taxon_list + ['p__', 'c__', 'o__', 'f__', 'g__', 's__']
        elif taxon_list[1].startswith('k') and len(taxon_list) == 2:
            continue
        else:
            if taxon_list[1].startswith('k'):
                taxon_list.pop(1)
            for i in range(rank_tile):
                if taxon_list[i][0] == rank_list[i]:
                    continue
                else:
                    taxon_list.insert(i, rank_list[i] + '__')
            if rank_tile < 6:
                for i in range(rank_tile + 1, 7):
                    taxon_list.insert(i, rank_list[i] + '__')
        new_line = line_list[0] + '\t' + '|'.join(taxon_list) + '\t' + line_list[2] + '\n'
        if int(line_list[2]) > 0:
            out_list.append(new_line)
    return out_list


# Main method
def main():
    # Parse arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('-r', '--report-file', '--report', required=True,
                        dest='r_file', help='Input kraken report file for converting')
    parser.add_argument('-o', '--output', required=True,
                        dest='o_file', help='Output trx-report file name')
    parser.add_argument('--add-header', default=False,
                        dest='add_header', required=False,
                        help='Add header in trx-report file, can use custom string [default: bracken file prefix]')
    parser.add_argument('--intermediate-ranks', action='store_true',
                        dest='x_include', default=False, required=False,
                        help='Include non-traditional taxonomic ranks in output')
    parser.add_argument('--no-intermediate-ranks', action='store_false',
                        dest='x_include', default=False, required=False,
                        help='Do not include non-traditional taxonomic ranks in output [default]')
    args = parser.parse_args()

    # Process report file and output
    curr_path = []
    prev_lvl_num = -1
    r_file = open(args.r_file, 'r')
    o_file = open(args.o_file, 'w')
    # Print header
    header = "TaxID\tTaxon\tSampleID\n"
    if not args.add_header:
        header = header.replace("SampleID", os.path.basename(args.r_file).replace(".bracken",""))
    else:
        header = header.replace("SampleID", args.add_header)
    o_file.write(header)

    # Read through report file
    main_lvls = ['R', 'K', 'D', 'P', 'C', 'O', 'F', 'G', 'S']
    out_list = []
    for line in r_file:
        report_vals = process_bracken_report(line)
        # If header line, skip
        if len(report_vals) < 7:
            continue
        # Get relevant information from the line
        [name, level_num, taxid, level_type, cur_reads, all_reads, percents] = report_vals
        if level_type == 'U':
            continue
        # Create level name
        if level_type not in main_lvls:
            level_type = "x"
        elif level_type == "K":
            level_type = "k"
        elif level_type == "D":
            level_type = "k"
        level_str = level_type.lower() + "__" + name
        # Determine full string to add
        if prev_lvl_num == -1:
            # First level
            prev_lvl_num = level_num
            curr_path.append(level_str)
        else:
            # Move back if needed
            while level_num != (prev_lvl_num + 1):
                prev_lvl_num -= 1
                curr_path.pop()
            # Print if at non-traditional level and that is requested
            if (level_type == "x" and args.x_include) or level_type != "x":
                out_list.append(str(taxid) + "\t")
                # Print all ancestors of current level followed by |
                for string in curr_path:
                    if (string[0] == "x" and args.x_include) or string[0] != "x":
                        if string[0] != "r":
                            out_list[-1] = out_list[-1] + string + "|"
                # Print final level and then number of reads
                out_list[-1] = out_list[-1] + level_str + "\t" + str(cur_reads) + "\n"
            # Update
            curr_path.append(level_str)
            prev_lvl_num = level_num
    o_file.writelines(full_level(out_list))
    o_file.close()
    r_file.close()


if __name__ == "__main__":
    main()
